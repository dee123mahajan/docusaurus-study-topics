"use strict";(self.webpackChunkStudy_React_js=self.webpackChunkStudy_React_js||[]).push([[816],{4416:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var s=r(4848),t=r(8453);const i={},a="Keys",o={id:"react/keys",title:"Keys",description:"In React, keys are unique identifiers used for efficiently rendering lists of components. They ensure proper updates by helping React identify changes, additions, and removals within arrays. Keys should be stable and unique among siblings to optimize performance and enable component reuse. They're essential for rendering arrays of components effectively.",source:"@site/docs/react/keys.md",sourceDirName:"react",slug:"/react/keys",permalink:"/docs/react/keys",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Higher order components",permalink:"/docs/react/hoc"}},c={},d=[{value:"Example",id:"example",level:4}];function l(e){const n={code:"code",h1:"h1",h4:"h4",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"keys",children:"Keys"}),"\n",(0,s.jsx)(n.p,{children:"In React, keys are unique identifiers used for efficiently rendering lists of components. They ensure proper updates by helping React identify changes, additions, and removals within arrays. Keys should be stable and unique among siblings to optimize performance and enable component reuse. They're essential for rendering arrays of components effectively."}),"\n",(0,s.jsx)(n.h4,{id:"example",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"function MyComponent() {\r\n  const items = ['apple', 'banana', 'orange'];\r\n\r\n  return (\r\n    <ul>\r\n      {items.map((item, index) => (\r\n        <li key={index}>{item}</li>\r\n      ))}\r\n    </ul>\r\n  );\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"In this example, each list item li is assigned a key based on its index in the array. While using array indices as keys is convenient, it's not always the best choice, especially if the order of items might change or if items can be added or removed. In such cases, using unique IDs or keys provided by data can be more appropriate."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"function MyComponent() {\r\n  const items = [\r\n    { id: 1, name: 'apple' },\r\n    { id: 2, name: 'banana' },\r\n    { id: 3, name: 'orange' },\r\n  ];\r\n\r\n  return (\r\n    <ul>\r\n      {items.map((item) => (\r\n        <li key={item.id}>{item.name}</li>\r\n      ))}\r\n    </ul>\r\n  );\r\n}\r\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"In this improved example, each item in the array has a unique id property, which is used as the key for each list item. This ensures stability and uniqueness across renders, improving performance and component reuse."})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var s=r(6540);const t={},i=s.createContext(t);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);