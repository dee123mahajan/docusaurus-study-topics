"use strict";(self.webpackChunkStudy_React_js=self.webpackChunkStudy_React_js||[]).push([[581],{5610:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"category","label":"Javascript","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Closures","href":"/docs/Javascript/Closures","docId":"Javascript/Closures","unlisted":false},{"type":"link","label":"Data types","href":"/docs/Javascript/PrimitiveNonPrimitive","docId":"Javascript/PrimitiveNonPrimitive","unlisted":false},{"type":"link","label":"Promises","href":"/docs/Javascript/Promises","docId":"Javascript/Promises","unlisted":false},{"type":"link","label":"This keyword","href":"/docs/Javascript/thiskeyword","docId":"Javascript/thiskeyword","unlisted":false},{"type":"link","label":"Async await","href":"/docs/Javascript/AsyncAwait","docId":"Javascript/AsyncAwait","unlisted":false},{"type":"link","label":"Callback","href":"/docs/Javascript/Callback","docId":"Javascript/Callback","unlisted":false},{"type":"link","label":"Functions","href":"/docs/Javascript/ArrowRegular","docId":"Javascript/ArrowRegular","unlisted":false},{"type":"link","label":"Timers","href":"/docs/Javascript/Timers","docId":"Javascript/Timers","unlisted":false},{"type":"link","label":"Hoisting","href":"/docs/Javascript/hoisting","docId":"Javascript/hoisting","unlisted":false},{"type":"link","label":"Let var const","href":"/docs/Javascript/letvarconst","docId":"Javascript/letvarconst","unlisted":false}],"href":"/docs/category/javascript"},{"type":"category","label":"React","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"React Hooks","href":"/docs/react/Hooks","docId":"react/Hooks","unlisted":false},{"type":"link","label":"Life cycle methods in React.js","href":"/docs/react/Lifecycle","docId":"react/Lifecycle","unlisted":false},{"type":"link","label":"Reconcilation , Diffing Algorithm, Virtual DOM","href":"/docs/react/Reconcillation","docId":"react/Reconcillation","unlisted":false},{"type":"link","label":"State and Props","href":"/docs/react/Stateprops","docId":"react/Stateprops","unlisted":false},{"type":"link","label":"Class and Functional Components","href":"/docs/react/classFunccomponents","docId":"react/classFunccomponents","unlisted":false},{"type":"link","label":"Code Splitting","href":"/docs/react/codeSplitting","docId":"react/codeSplitting","unlisted":false},{"type":"link","label":"Context Api","href":"/docs/react/contextApi","docId":"react/contextApi","unlisted":false},{"type":"link","label":"Controlled/Uncontrolled Components","href":"/docs/react/controlledcomp","docId":"react/controlledcomp","unlisted":false},{"type":"link","label":"Higher order components","href":"/docs/react/hoc","docId":"react/hoc","unlisted":false},{"type":"link","label":"Keys","href":"/docs/react/keys","docId":"react/keys","unlisted":false}],"href":"/docs/category/react"}]},"docs":{"Javascript/ArrowRegular":{"id":"Javascript/ArrowRegular","title":"Functions","description":"Regular Functions:","sidebar":"tutorialSidebar"},"Javascript/AsyncAwait":{"id":"Javascript/AsyncAwait","title":"Async await","description":"Async/await is a feature in JavaScript that allows you to work with asynchronous code in a more synchronous-like manner, making it easier to write and understand asynchronous code.","sidebar":"tutorialSidebar"},"Javascript/Callback":{"id":"Javascript/Callback","title":"Callback","description":"Callbacks in JavaScript are functions passed as arguments to other functions to be executed later, typically after an asynchronous operation has completed or when a certain condition is met. Callbacks are a fundamental part of JavaScript\'s asynchronous programming model, allowing you to perform tasks asynchronously without blocking the execution of other code.","sidebar":"tutorialSidebar"},"Javascript/Closures":{"id":"Javascript/Closures","title":"Closures","description":"A closure is a function that remembers the variables from the outer scope even after that scope has finished executing. It\'s like a backpack that the inner function carries around, containing all the variables it needs from the outer function. For instance, in JavaScript:","sidebar":"tutorialSidebar"},"Javascript/hoisting":{"id":"Javascript/hoisting","title":"Hoisting","description":"Hoisting is a behavior in JavaScript where variable and function declarations are moved to the top of their containing scope during the compilation phase, before the code is executed. This means that regardless of where variables and functions are declared in the code, they are actually processed first by the JavaScript engine.","sidebar":"tutorialSidebar"},"Javascript/letvarconst":{"id":"Javascript/letvarconst","title":"Let var const","description":"In JavaScript, let, var, and const are used for variable declaration, but they have different behaviors and scopes.","sidebar":"tutorialSidebar"},"Javascript/PrimitiveNonPrimitive":{"id":"Javascript/PrimitiveNonPrimitive","title":"Data types","description":"In JavaScript, primitive data types are simple data types that represent single values, while non-primitive data types are more complex and can hold multiple values or other data types. Here\'s a simplified explanation:","sidebar":"tutorialSidebar"},"Javascript/Promises":{"id":"Javascript/Promises","title":"Promises","description":"Promises in JavaScript provide a way to handle asynchronous operations more effectively, ensuring better control flow and error handling. A promise represents a value that may be available now, in the future, or never.","sidebar":"tutorialSidebar"},"Javascript/thiskeyword":{"id":"Javascript/thiskeyword","title":"This keyword","description":"In JavaScript, the \'this\' keyword signifies the environment in which a function operates. Primarily, it symbolizes the object to which the function is attached when it\'s invoked. Nevertheless, the \'this\' value is dynamic and can alter based on the method of invocation.","sidebar":"tutorialSidebar"},"Javascript/Timers":{"id":"Javascript/Timers","title":"Timers","description":"In JavaScript, setTimeout, setInterval, and setImmediate are all functions used to execute code asynchronously, but they have different behaviors and use cases.","sidebar":"tutorialSidebar"},"react/classFunccomponents":{"id":"react/classFunccomponents","title":"Class and Functional Components","description":"In React, components are the building blocks of a user interface. There are two primary types of components in React: class components and functional components.","sidebar":"tutorialSidebar"},"react/codeSplitting":{"id":"react/codeSplitting","title":"Code Splitting","description":"Code splitting is an essential technique in modern web development to optimize the performance of React applications. It allows you to split your JavaScript bundle into smaller chunks. With code splitting, you can only load the code that is needed in a particular context, reducing the initial load time and improving the overall user experience.","sidebar":"tutorialSidebar"},"react/contextApi":{"id":"react/contextApi","title":"Context Api","description":"In React, the Context API provides a way to pass data through the component tree without having to pass props down manually at every level. This can be especially useful for passing global data or theme information throughout an application.","sidebar":"tutorialSidebar"},"react/controlledcomp":{"id":"react/controlledcomp","title":"Controlled/Uncontrolled Components","description":"In React, Controlled components refer to the components where the state and behaviors are controlled by Parent components while Uncontrolled components are the ones having control of their own state and manage the behaviors on themselves.","sidebar":"tutorialSidebar"},"react/hoc":{"id":"react/hoc","title":"Higher order components","description":"Higher-order components (HOCs) are a powerful feature of the React library. They allow you to reuse component logic across multiple components.","sidebar":"tutorialSidebar"},"react/Hooks":{"id":"react/Hooks","title":"React Hooks","description":"React Hooks are functions that let you use state and other React features without writing a class. They are introduced in React 16.8 as a way to write more concise and readable React code, especially functional components. Hooks are JavaScript functions, but they have specific names and conventions that let React maintain the state of a functional component between renders.","sidebar":"tutorialSidebar"},"react/keys":{"id":"react/keys","title":"Keys","description":"In React, keys are unique identifiers used for efficiently rendering lists of components. They ensure proper updates by helping React identify changes, additions, and removals within arrays. Keys should be stable and unique among siblings to optimize performance and enable component reuse. They\'re essential for rendering arrays of components effectively.","sidebar":"tutorialSidebar"},"react/Lifecycle":{"id":"react/Lifecycle","title":"Life cycle methods in React.js","description":"In React, lifecycle methods are special methods that are invoked at various stages of a component\'s lifecycle. These methods provide developers with the ability to hook into specific points in the lifecycle of a component, allowing them to perform actions such as setting up state, fetching data, updating the DOM, and cleaning up resources. However, with the introduction of React Hooks, many of these lifecycle methods have been deprecated in favor of Hooks-based alternatives.","sidebar":"tutorialSidebar"},"react/Reconcillation":{"id":"react/Reconcillation","title":"Reconcilation , Diffing Algorithm, Virtual DOM","description":"Virtual DOM:","sidebar":"tutorialSidebar"},"react/Stateprops":{"id":"react/Stateprops","title":"State and Props","description":"State","sidebar":"tutorialSidebar"}}}')}}]);